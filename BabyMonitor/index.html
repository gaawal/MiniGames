<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åƒç´ å©´å„¿å…»æˆæœº - å¢å¼ºç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <!-- æ·»åŠ Font Awesomeå›¾æ ‡åº“ -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- å†…åµŒåŠ¨ä½œé…ç½®ï¼ˆä¾¿äºåç»­æŠ½ç¦»ä¸ºç‹¬ç«‹æ–‡ä»¶ï¼‰ -->
    <script id="actions-config" type="application/json">
        {
            "feed": [
                {"label": "æ¯ä¹³", "effect": {"satiation": 80, "energy": 5, "happiness": 5}, "message": "å–‚äº†æ¯ä¹³", "requireAwake": true, "growth": {"morality": 1, "physical": 1}},
                {"label": "é…æ–¹å¥¶", "effect": {"satiation": 50, "energy": 5, "happiness": 3}, "message": "å–‚äº†é…æ–¹å¥¶", "requireAwake": true},
                {"label": "ç±³ç³Š", "effect": {"satiation": 45, "energy": 3, "happiness": 2}, "message": "å–‚äº†ç±³ç³Š", "requireAwake": true},
                {"label": "æ°´æœæ³¥", "effect": {"satiation": 30, "energy": 2, "happiness": 8}, "message": "å–‚äº†æ°´æœæ³¥", "requireAwake": true, "growth": {"aesthetics": 1}},
                {"label": "è”¬èœæ³¥", "effect": {"satiation": 12, "energy": 3, "health": 3}, "message": "å–‚äº†è”¬èœæ³¥", "requireAwake": true},
                {"label": "é¸¡è›‹ç¾¹", "effect": {"satiation": 30, "energy": 4, "happiness": 15}, "message": "å–‚äº†é¸¡è›‹ç¾¹", "requireAwake": true},
                {"label": "é±¼è‚‰æ³¥", "effect": {"satiation": 16, "energy": 3, "health": 5}, "message": "å–‚äº†é±¼è‚‰æ³¥", "requireAwake": true},
                {"label": "é¥¼å¹²", "effect": {"satiation": 15, "happiness": 35, "hygiene": -5}, "message": "å–‚äº†é¥¼å¹²", "requireAwake": true}
            ],
            "clean": [
                {"label": "æ¢å°¿å¸ƒ", "effect": {"hygiene": 40, "happiness": 5}, "message": "æ¢äº†å°¿å¸ƒ", "poopClean": true, "growth": {"morality": 1}},
                {"label": "æ´—æ¾¡", "effect": {"hygiene": 40, "happiness": 10}, "message": "æ´—äº†æ¾¡", "requireAwake": true},
                {"label": "æ“¦è„¸", "effect": {"hygiene": 15, "happiness": 3}, "message": "æ“¦äº†è„¸", "requireAwake": true},
                {"label": "æ¢è¡£æœ", "effect": {"hygiene": 20, "happiness": 5}, "message": "æ¢äº†è¡£æœ", "requireAwake": true},
                {"label": "æ´—æ‰‹", "effect": {"hygiene": 10, "happiness": 2}, "message": "æ´—äº†æ‰‹", "requireAwake": true},
                {"label": "æ¢³å¤´", "effect": {"hygiene": 8, "happiness": 4}, "message": "æ¢³äº†å¤´", "requireAwake": true},
                {"label": "å‰ªæŒ‡ç”²", "effect": {"hygiene": 12, "happiness": -3}, "message": "å‰ªäº†æŒ‡ç”²", "requireAwake": true},
                {"label": "æ¸…ç†è€³æœµ", "effect": {"hygiene": 15, "happiness": -5}, "message": "æ¸…ç†äº†è€³æœµ", "requireAwake": true}
            ],
            "play": [
                {"label": "æ‘‡é“ƒ", "effect": {"happiness": 15, "energy": -10, "satiation": -5}, "message": "ç©äº†æ‘‡é“ƒ", "requireAwake": true, "growth": {"intelligence": 1}},
                {"label": "èº²çŒ«çŒ«", "effect": {"happiness": 20, "energy": -15, "satiation": -7}, "message": "ç©äº†èº²çŒ«çŒ«", "requireAwake": true, "growth": {"intelligence": 1}},
                {"label": "è®²æ•…äº‹", "effect": {"happiness": 10, "energy": -5, "satiation": -3}, "message": "è®²äº†æ•…äº‹", "requireAwake": true},
                {"label": "å”±æ­Œ", "effect": {"happiness": 12, "energy": -8, "satiation": -4}, "message": "å”±äº†æ­Œ", "requireAwake": true},
                {"label": "æ­ç§¯æœ¨", "effect": {"happiness": 18, "energy": -12, "satiation": -6}, "message": "æ­äº†ç§¯æœ¨", "requireAwake": true, "growth": {"intelligence": 2}},
                {"label": "ç©å¨ƒå¨ƒ", "effect": {"happiness": 16, "energy": -9, "satiation": -5}, "message": "ç©äº†å¨ƒå¨ƒ", "requireAwake": true, "growth": {"aesthetics": 1}},
                {"label": "ç©çƒ", "effect": {"happiness": 22, "energy": -18, "satiation": -8}, "message": "ç©äº†çƒ", "requireAwake": true, "growth": {"physical": 2}},
                {"label": "è·³èˆ", "effect": {"happiness": 25, "energy": -20, "satiation": -10}, "message": "è·³äº†èˆ", "requireAwake": true, "growth": {"aesthetics": 2}}
            ],
            "sleep": [
                {"label": "æ‘‡ç¯®æ›²", "effect": {"energy": 45, "happiness": 5}, "message": "å”±äº†æ‘‡ç¯®æ›²", "requireAwake": true},
                {"label": "è½»æ‹", "effect": {"energy": 15, "happiness": 3}, "message": "è½»è½»æ‹èƒŒ", "requireAwake": true},
                {"label": "å®‰æŠšå¥¶å˜´", "effect": {"energy": 10, "happiness": 2}, "message": "ç”¨äº†å®‰æŠšå¥¶å˜´", "requireAwake": true},
                {"label": "æŠ±ç€èµ°", "effect": {"energy": 25, "happiness": 4}, "message": "æŠ±ç€èµ°åŠ¨", "requireAwake": true},
                {"label": "è®²æ•…äº‹", "effect": {"energy": 12, "happiness": 3}, "message": "è®²äº†ç¡å‰æ•…äº‹", "requireAwake": true},
                {"label": "æ”¾ç™½å™ªéŸ³", "effect": {"energy": 18, "happiness": 2}, "message": "æ”¾äº†ç™½å™ªéŸ³", "requireAwake": true},
                {"label": "æŒ‰æ‘©", "effect": {"energy": 22, "happiness": 5}, "message": "åšäº†æŒ‰æ‘©", "requireAwake": true},
                {"label": "å…³ç¯", "effect": {"energy": 30, "happiness": -3}, "message": "å…³äº†ç¯", "requireAwake": true}
            ],
            "doctor": [
                {"label": "é‡ä½“æ¸©", "effect": {"health": 5, "happiness": -2}, "message": "é‡äº†ä½“æ¸©"},
                {"label": "å–‚è¯", "effect": {"health": 40, "happiness": -5}, "message": "å–‚äº†è¯", "growth": {"morality": 1}},
                {"label": "çœ‹åŒ»ç”Ÿ", "effect": {"health": 45, "happiness": -8}, "message": "çœ‹äº†åŒ»ç”Ÿ"},
                {"label": "ç»´ç”Ÿç´ ", "effect": {"health": 10, "happiness": 1}, "message": "åƒäº†ç»´ç”Ÿç´ "},
                {"label": "æ‰“ç–«è‹—", "effect": {"health": 15, "happiness": -10}, "message": "æ‰“äº†ç–«è‹—"},
                {"label": "ç‰©ç†é™æ¸©", "effect": {"health": 12, "happiness": -3}, "message": "åšäº†ç‰©ç†é™æ¸©"},
                {"label": "å–‚æ°´", "effect": {"health": 8, "happiness": 1}, "message": "å–‚äº†æ°´"},
                {"label": "æ£€æŸ¥è€³æœµ", "effect": {"health": 7, "happiness": -2}, "message": "æ£€æŸ¥äº†è€³æœµ"}
            ]
        }
    </script>
    <!-- å†…åµŒäº‹ä»¶é…ç½®ï¼ˆä¾¿äºåç»­æŠ½ç¦»ä¸ºç‹¬ç«‹æ–‡ä»¶ï¼‰ -->
    <script id="events-config" type="application/json">
        {
            "events": [
                {
                    "id": "crying",
                    "label": "å“­é—¹",
                    "trigger": { "chanceHourly": 0.4, "whenAwake": true, "anyBelow": { "satiation": 30, "energy": 30, "happiness": 40 } },
                    "durationMinutes": 60,
                    "flags": { "isCrying": true },
                    "modifiers": {
                        "actionSuccess": { "feed": -0.15 },
                        "actionEffectMultiplier": { "feed.satiation": 0.85 },
                        "happinessDecayPerMinute": 0.2
                    }
                },
                {
                    "id": "hungry",
                    "label": "é¥¿äº†",
                    "trigger": { "chanceHourly": 0.25 },
                    "durationMinutes": 60,
                    "modifiers": { "actionSuccess": { "feed": -0.05 }, "actionEffectMultiplier": { "feed.satiation": 0.9 } }
                },
                {
                    "id": "pooped",
                    "label": "ä¾¿ä¾¿äº†",
                    "trigger": { "chanceHourly": 0.2 },
                    "durationMinutes": 120,
                    "flags": { "hasPooped": true },
                    "modifiers": { "hygieneDecayPerMinute": 0.3, "happinessModifier": -0.5 },
                    "clearOnAction": "clean"
                }
            ]
        }
    </script>
    <link rel="stylesheet" href="assets/styles.css">
</head>
<body>
<div id="app" class="container mx-auto px-4 max-w-md">
    <div class="game-title">åƒç´ å©´å„¿å…»æˆæœº</div>
    <div class="game-subtitle">ç…§é¡¾å¥½ä½ çš„åƒç´ å®å®ï¼</div>

    <!-- æ¸¸æˆæœºå™¨ -->
    <div class="bg-red-500 rounded-2xl p-4 shadow-2xl relative">
        <!-- æ¸¸æˆç»“æŸè¦†ç›–å±‚ -->
        <div v-if="gameOver" class="game-overlay">
            <h2>æ¸¸æˆç»“æŸ</h2>
            <p>å®å®æ²¡èƒ½æ’‘è¿‡ç¬¬{{ day }}å¤©</p>
            <p class="text-red-400">{{ deathReason }}</p>

            <div class="stats">
                <p>æ¸¸æˆæ—¶é—´: {{ playTime }}åˆ†é’Ÿ</p>
                <p>å®å®å¹´é¾„: {{ ageDisplay }}</p>
                <p>æœ€ç»ˆä½“é‡: {{ Math.round(weight / 1000) }} kg</p>
            </div>

            <button @click="resetGame" class="bg-blue-600 px-4 py-2 rounded hover:bg-blue-700 mt-4">
                é‡æ–°å¼€å§‹
            </button>
        </div>

        <!-- å‡ºç”Ÿå¼¹çª— -->
        <div v-if="showBirthModal" class="game-overlay">
            <h2>å®å®è¯ç”Ÿäº†ï¼</h2>
            <div class="stats">
                <p class="mb-2">è¯·çœ‹çœ‹ä½ å®¶å®å®çš„å…ˆå¤©èµ„è´¨</p>
                <div class="status-row"><span class="status-label">å¾·</span>
                    <span class="flex-1 ml-2 status-bar"><span class="status-fill" :style="{width: getRacePct(race.morality), background:'#78C850'}"></span></span>
                    <span class="ml-2">{{ race.morality }}</span>
                </div>
                <div class="status-row"><span class="status-label">æ™º</span>
                    <span class="flex-1 ml-2 status-bar"><span class="status-fill" :style="{width: getRacePct(race.intelligence), background:'#6890F0'}"></span></span>
                    <span class="ml-2">{{ race.intelligence }}</span>
                </div>
                <div class="status-row"><span class="status-label">ä½“</span>
                    <span class="flex-1 ml-2 status-bar"><span class="status-fill" :style="{width: getRacePct(race.physical), background:'#F08030'}"></span></span>
                    <span class="ml-2">{{ race.physical }}</span>
                </div>
                <div class="status-row"><span class="status-label">ç¾</span>
                    <span class="flex-1 ml-2 status-bar"><span class="status-fill" :style="{width: getRacePct(race.aesthetics), background:'#F85888'}"></span></span>
                    <span class="ml-2">{{ race.aesthetics }}</span>
                </div>
                <div class="status-row"><span class="status-label">åŠ³</span>
                    <span class="flex-1 ml-2 status-bar"><span class="status-fill" :style="{width: getRacePct(race.labor), background:'#A8B820'}"></span></span>
                    <span class="ml-2">{{ race.labor }}</span>
                </div>
                <div class="status-row"><span class="status-label">æƒ³è±¡åŠ›</span>
                    <span class="flex-1 ml-2 status-bar"><span class="status-fill" :style="{width: getRacePct(race.imagination), background:'#7038F8'}"></span></span>
                    <span class="ml-2">{{ race.imagination }}</span>
                </div>
                <div class="text-center mt-3 text-xs">æ€»å’Œâ‰ˆ500ï¼ˆå•é¡¹ä¸Šé™252ï¼‰</div>
            </div>
            <button @click="closeBirthModal" class="bg-blue-600 px-4 py-2 rounded hover:bg-blue-700 mt-4">å¼€å§‹æ¸¸æˆ</button>
        </div>

        <!-- å±å¹•åŒºåŸŸ -->
        <div class="lcd-screen rounded-lg relative screen-container">
            <!-- çŠ¶æ€æ  -->
            <div class="grid grid-cols-5 gap-2 p-2">
                <div v-for="(value, key) in status" :key="key" class="text-center">
                    <div class="text-xs text-gray-700 mb-1">{{ getStatusName(key) }}</div>
                    <div class="status-bar">
                        <div class="status-fill" :class="getStatusColor(value, maxStatus[key])"
                             :style="{width: (value / maxStatus[key] * 100) + '%'}"></div>
                    </div>
                    <div class="status-value">{{ Math.round(value) }}/{{ maxStatus[key] }}</div>
                </div>
            </div>

            <!-- å©´å„¿æ˜¾ç¤ºåŒºåŸŸ -->
            <div class="baby-container">
                <!-- å©´å„¿çŠ¶æ€æŒ‡ç¤º -->
                <div class="baby-state">
                    <i :class="getStateIcon(babyState)"></i>{{ babyState }}
                </div>

                <!-- å©´å„¿è¡¨æƒ… -->
                <div class="baby-emoji">
                    {{ babyEmoji }}
                </div>

                <!-- æ—¶é—´æ˜¾ç¤º -->
                <div class="time-display">
                    ç¬¬{{ day }}å¤© {{ formattedTime }}
                </div>

                <!-- 3Då©´å„¿æ¨¡å‹å®¹å™¨ -->
                <div id="baby-canvas-container" class="w-full h-full relative">
                    <canvas id="baby-canvas"></canvas>
                </div>

                <!-- äº¤äº’æç¤º -->
                <div v-if="currentEvent" class="absolute top-0 left-0 right-0 text-center text-sm text-red-600 blink">
                    {{ currentEvent }}
                </div>

                <!-- åŠ¨ä½œåé¦ˆ -->
                <div v-if="actionFeedback" class="absolute bottom-2 left-0 right-0 text-center text-sm"
                     :class="actionFeedbackClass">
                    {{ actionFeedback }}
                </div>

                <div v-for="(feedback, index) in effectFeedbacks" :key="index"
                     class="effect-feedback"
                     :class="feedback.class"
                     :style="{
            top: `calc(40% + ${feedback.offsetY}px)`,
            left: `calc(50% + ${feedback.offsetX}px)`,
            animation: feedback.animation + ' 1.5s forwards'
        }">
                    {{ feedback.text }}
                </div>
            </div>

            <!-- çŠ¶æ€æ€»è§ˆé¢æ¿ï¼ˆä»…å±•ç¤ºå¤©æ•°/é˜¶æ®µ/ä½“é‡/å…ˆå¤©ç§æ—/æˆé•¿å€¾å‘ï¼‰ -->
            <div v-if="currentView === 'status'" class="status-panel m-2">
                <div class="status-row"><span class="status-label">å¤©æ•°:</span><span>{{ day }}</span></div>
                <div class="status-row"><span class="status-label">é˜¶æ®µ:</span><span>{{ ageDisplay }}</span></div>
                <div class="status-row"><span class="status-label">ä½“é‡:</span><span>{{ Math.round(weight / 1000) }} kg</span></div>
                <div class="status-row"><span class="status-label">æˆé•¿å€¾å‘:</span><span>{{ growthTendency.label }}</span></div>
                <div class="status-row"><span class="status-label">å¾·:</span>
                    <span class="flex-1 ml-2 status-bar"><span class="status-fill" :style="{width: getRacePct(race.morality), background:'#78C850'}"></span></span>
                    <span class="ml-2">{{ race.morality }}</span>
                </div>
                <div class="status-row"><span class="status-label">æ™º:</span>
                    <span class="flex-1 ml-2 status-bar"><span class="status-fill" :style="{width: getRacePct(race.intelligence), background:'#6890F0'}"></span></span>
                    <span class="ml-2">{{ race.intelligence }}</span>
                </div>
                <div class="status-row"><span class="status-label">ä½“:</span>
                    <span class="flex-1 ml-2 status-bar"><span class="status-fill" :style="{width: getRacePct(race.physical), background:'#F08030'}"></span></span>
                    <span class="ml-2">{{ race.physical }}</span>
                </div>
                <div class="status-row"><span class="status-label">ç¾:</span>
                    <span class="flex-1 ml-2 status-bar"><span class="status-fill" :style="{width: getRacePct(race.aesthetics), background:'#F85888'}"></span></span>
                    <span class="ml-2">{{ race.aesthetics }}</span>
                </div>
                <div class="status-row"><span class="status-label">åŠ³:</span>
                    <span class="flex-1 ml-2 status-bar"><span class="status-fill" :style="{width: getRacePct(race.labor), background:'#A8B820'}"></span></span>
                    <span class="ml-2">{{ race.labor }}</span>
                </div>
                <div class="status-row"><span class="status-label">æƒ³è±¡åŠ›:</span>
                    <span class="flex-1 ml-2 status-bar"><span class="status-fill" :style="{width: getRacePct(race.imagination), background:'#7038F8'}"></span></span>
                    <span class="ml-2">{{ race.imagination }}</span>
                </div>
            </div>

            <!-- å­é€‰é¡¹é¢æ¿ -->
            <div v-if="currentView === 'submenu'" class="submenu m-2">
                <div class="submenu-title">{{ currentSubmenuTitle }}</div>
                <div class="submenu-options">
                    <div v-for="(option, index) in currentSubmenuOptions" :key="index"
                         class="submenu-option" :class="{ selected: selectedSubmenuIndex === index }"
                         @click="selectSubmenuOption(index)">
                        {{ option.label }}
                    </div>
                </div>
            </div>

            <!-- æ¶ˆæ¯å†å² -->
            <div v-if="currentView === 'main'" class="message-history m-2">
                <div v-for="(msg, index) in messageHistory" :key="index" class="message-item">
                    <span class="message-time">{{ msg.time }}</span>{{ msg.text }}
                </div>
            </div>

            <!-- åŠ¨ä½œå›¾æ ‡æ  -->
            <div v-if="currentView === 'main'" class="flex justify-between mt-2 px-4 pb-2">
                <div v-for="(action, index) in actions" :key="action.name"
                     class="flex flex-col items-center">
                    <div class="action-icon" :class="{ selected: selectedActionIndex === index }"
                         :title="action.label">
                        <i :class="action.icon"></i>
                    </div>
                    <div class="icon-title">{{ action.label }}</div>
                </div>
            </div>
        </div>

        <!-- æ§åˆ¶æŒ‰é’® -->
        <div class="controls-container">
            <div class="text-center">
                <div class="button button-nav" @click="navigate">â–¶</div>
                <div class="text-xs text-white mt-1">é€‰æ‹©</div>
            </div>

            <div class="text-center relative">
                <div class="button button-action" @click="performAction">
                    <div v-if="isCoolingDown" class="cooldown-overlay">
                        <div class="cooldown-spinner"></div>
                        <span style="font-size: 10px">{{ cooldownTime }}</span>
                    </div>
                    âœ“
                </div>
                <div class="text-xs text-white mt-1">ç¡®è®¤</div>
            </div>

            <div class="text-center">
                <div class="button button-back" @click="cancelAction">âœ—</div>
                <div class="text-xs text-white mt-1">å–æ¶ˆ</div>
            </div>
        </div>
    </div>

    <!-- æ¸¸æˆä¿¡æ¯ -->
    <div class="mt-4 text-white text-center">
        <p class="text-sm mb-2">ç¬¬{{ day }}å¤© - å®å®å¥åº·: {{ Math.round(status.health) }}/{{ maxStatus.health }}</p>
        <p class="text-xs mb-2">æ¸¸æˆæ—¶é—´: 1ç§’ = 10åˆ†é’Ÿ | ä½¿ç”¨é€‰æ‹©é”®é€‰æ‹©ï¼Œç¡®è®¤é”®æ‰§è¡Œ</p>
        <button @click="resetGame" class="bg-blue-600 px-4 py-2 rounded hover:bg-blue-700 text-xs">é‡ç½®æ¸¸æˆ</button>
    </div>
</div>

<script>
    const {createApp, ref, computed, onMounted, onUnmounted} = Vue;

    createApp({
        setup() {
            // çŠ¶æ€æœ€å¤§å€¼ï¼ˆéšå¤©æ•°å¢åŠ ï¼‰
            const maxStatus = ref({
                satiation: 100,
                energy: 100,
                health: 100,
                hygiene: 100,
                happiness: 100
            });

            // æ¸¸æˆçŠ¶æ€
            const status = ref({
                satiation: 80,
                energy: 70,
                health: 90,
                hygiene: 85,
                happiness: 75
            });

            // æ¸¸æˆå˜é‡
            const gameTime = ref(0);
            const sleepDuration = ref(0);
            const day = ref(1);
            const hour = ref(8);
            const minute = ref(0);
            const weight = ref(3200);
            const isSleeping = ref(false);
            const isCrying = ref(false);
            const hasPooped = ref(false);
            const currentEvent = ref(null);
            const actionFeedback = ref(null);
            const actionFeedbackClass = ref('');
            const effectFeedbacks = ref([]);
            const gameInterval = ref(null);
            const selectedActionIndex = ref(0);
            const messageHistory = ref([]);
            const currentView = ref('main');
            const currentSubmenuTitle = ref('');
            const currentSubmenuOptions = ref([]);
            const selectedSubmenuIndex = ref(0);
            // æˆé•¿ç³»ç»Ÿï¼ˆå¾·æ™ºä½“ç¾åŠ³ï¼‰
            const growth = ref({
                morality: 0,
                intelligence: 0,
                physical: 0,
                aesthetics: 0,
                labor: 0
            });
            // æˆé•¿åŠ æˆå¼€å…³ï¼ˆé»˜è®¤å…³é—­ï¼Œä¿æŒå¹³è¡¡ï¼‰
            const enableGrowthBonuses = ref(false);
            const growthTendency = computed(() => {
                const entries = Object.entries(growth.value);
                if (!entries.length) return { key: '-', label: 'æ— ' };
                const [key] = entries.reduce((a, b) => (a[1] >= b[1] ? a : b));
                const map = { morality: 'å¾·', intelligence: 'æ™º', physical: 'ä½“', aesthetics: 'ç¾', labor: 'åŠ³' };
                return { key, label: map[key] || key };
            });
            // å¿ƒæƒ…ç³»ç»Ÿï¼šç”±å¿«ä¹åº¦æ˜ å°„
            const mood = ref('neutral'); // happy | neutral | sad
            const updateMood = () => {
                const happinessPct = status.value.happiness / maxStatus.value.happiness;
                if (happinessPct >= 0.8) mood.value = 'happy';
                else if (happinessPct <= 0.3) mood.value = 'sad';
                else mood.value = 'neutral';
            };
            // ç§æ—å€¼ç³»ç»Ÿï¼ˆå¾·æ™ºä½“ç¾åŠ³ + æƒ³è±¡åŠ›ï¼‰ï¼Œåˆå§‹æ€»å’Œâ‰ˆ500
            const race = ref({ morality: 0, intelligence: 0, physical: 0, aesthetics: 0, labor: 0, imagination: 0 });
            const initRace = () => {
                const keys = Object.keys(race.value);
                const parts = Array(keys.length).fill(0).map(() => Math.random());
                const sum = parts.reduce((a, b) => a + b, 0);
                let remaining = 500;
                keys.forEach((k, i) => {
                    const v = i === keys.length - 1 ? remaining : Math.max(40, Math.round((parts[i] / sum) * 500));
                    race.value[k] = v;
                    remaining -= v;
                });
            };
            // è¡Œä¸ºå†å²è®¡æ•°ï¼Œç”¨äºå‡çº§æ¼”åŒ–
            const actionHistory = ref({ feed: 0, clean: 0, play: 0, sleep: 0, doctor: 0 });
            // äº‹ä»¶ç³»ç»Ÿï¼šä»é…ç½®è¯»å–ï¼ˆå“åº”å¼ã€ä¾¿äºå¤–éƒ¨åŠ è½½è¦†ç›–ï¼‰
            const eventsConfig = ref(JSON.parse(document.getElementById('events-config').textContent));
            const activeEvents = ref([]); // { id, expiresAtMinute }

            const gameOver = ref(false);
            const deathReason = ref('');
            const isCoolingDown = ref(false);
            const cooldownTime = ref(0);
            const cooldownInterval = ref(null);
            // å‡ºç”Ÿå¼¹çª—
            const showBirthModal = ref(true);
// è®¡ç®—æ¸¸æˆæ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
            const playTime = computed(() => {
                return Math.floor(gameTime.value / 1000 * 10);
            });
            // æ‰€æœ‰å¯èƒ½çš„åŠ¨ä½œé€‰é¡¹ï¼ˆä»å†…åµŒé…ç½®è¯»å–ï¼Œå…è®¸å¤–éƒ¨åŠ è½½è¦†ç›–ï¼‰
            const allActions = ref(JSON.parse(document.getElementById('actions-config').textContent));

            // å¯ç”¨åŠ¨ä½œ
            const actions = ref([
                {name: 'feed', icon: 'fas fa-utensils', label: 'å–‚é£Ÿ', submenu: 'é€‰æ‹©é£Ÿç‰©'},
                {name: 'clean', icon: 'fas fa-bath', label: 'æ¸…æ´', submenu: 'æ¸…æ´æ–¹å¼'},
                {name: 'play', icon: 'fas fa-gamepad', label: 'æ¸¸æˆ', submenu: 'æ¸¸æˆæ–¹å¼'},
                {name: 'sleep', icon: 'fas fa-moon', label: 'ç¡è§‰', submenu: 'å“„ç¡æ–¹å¼'},
                {name: 'doctor', icon: 'fas fa-heart-pulse', label: 'åŒ»ç–—', submenu: 'åŒ»ç–—æ–¹å¼'},
                {name: 'status', icon: 'fas fa-chart-simple', label: 'çŠ¶æ€', submenu: null}
            ]);

            // è®¡ç®—å±æ€§
            const ageDisplay = computed(() => {
                if (day.value < 3) return 'æ–°ç”Ÿå„¿';
                if (day.value < 7) return 'å©´å„¿';
                return 'å¹¼å„¿';
            });

            const formattedTime = computed(() => {
                return `${hour.value.toString().padStart(2, '0')}:${minute.value.toString().padStart(2, '0')}`;
            });

            const babyState = computed(() => {
                if (isSleeping.value) return 'ç¡è§‰ä¸­';
                if (isCrying.value) return 'å“­é—¹ä¸­';
                if (hasPooped.value) return 'ä¾¿ä¾¿äº†';
                if (status.value.satiation < maxStatus.value.satiation * 0.2) return 'é¥¿äº†';
                if (status.value.energy < maxStatus.value.energy * 0.2) return 'å›°å€¦';
                if (status.value.hygiene < maxStatus.value.hygiene * 0.2) return 'è„äº†';
                if (status.value.health < maxStatus.value.health * 0.5) return 'ç”Ÿç—…äº†';
                if (status.value.happiness > maxStatus.value.happiness * 0.8) return 'å¼€å¿ƒ';
                return 'æ­£å¸¸';
            });

            // æ›´æ–°åçš„babyEmojiè®¡ç®—é€»è¾‘
            const babyEmoji = computed(() => {
                if (gameOver.value) return 'ğŸ˜­';
                if (isSleeping.value) return 'ğŸ˜´';
                if (isCrying.value) return 'ğŸ˜­';
                if (hasPooped.value) return 'ğŸ’©';
                if (status.value.satiation < maxStatus.value.satiation * 0.2) return 'ğŸ˜«';
                if (status.value.energy < maxStatus.value.energy * 0.3) return 'ğŸ˜ª';
                if (status.value.hygiene < maxStatus.value.hygiene * 0.3) return 'ğŸ¤¢';
                if (status.value.health < maxStatus.value.health * 0.7) return 'ğŸ¤’';
                if (status.value.health < maxStatus.value.health * 0.4) return 'ğŸ¤•';
                if (status.value.happiness < maxStatus.value.happiness * 0.4) return 'ğŸ˜Ÿ';
                if (status.value.happiness > maxStatus.value.happiness * 0.8) return 'ğŸ˜Š';
                return 'ğŸ‘¶';
            });

            // çŠ¶æ€é¢œè‰²
            const getStatusColor = (value, maxValue) => {
                const percentage = (value / maxValue) * 100;
                if (percentage > 80) return 'bg-green-500';
                if (percentage > 50) return 'bg-yellow-500'; // é™ä½é˜ˆå€¼
                if (percentage > 30) return 'bg-orange-500'; // æ·»åŠ ä¸­é—´çº§åˆ«
                return 'bg-red-500';
            };

            // çŠ¶æ€åç§°
            const getStatusName = (key) => {
                const names = {
                    satiation: 'é¥±è…¹',
                    energy: 'ç²¾åŠ›',
                    health: 'å¥åº·',
                    hygiene: 'å«ç”Ÿ',
                    happiness: 'å¿«ä¹'
                };
                return names[key] || key;
            };

            // çŠ¶æ€å›¾æ ‡
            const getStateIcon = (state) => {
                const icons = {
                    'ç¡è§‰ä¸­': 'fas fa-bed',
                    'å“­é—¹ä¸­': 'fas fa-tired',
                    'ä¾¿ä¾¿äº†': 'fas fa-poop',
                    'é¥¿äº†': 'fas fa-utensils',
                    'å›°å€¦': 'fas fa-moon',
                    'è„äº†': 'fas fa-shower',
                    'ç”Ÿç—…äº†': 'fas fa-thermometer-half',
                    'å¼€å¿ƒ': 'fas fa-laugh',
                    'æ­£å¸¸': 'fas fa-smile'
                };
                return icons[state] || 'fas fa-baby';
            };

            // äº‹ä»¶ä¿®æ­£æŸ¥è¯¢
            const getActionSuccessModifier = (actionName) => {
                let delta = 0;
                for (const e of activeEvents.value) {
                    const def = eventsConfig.value.events.find(ev => ev.id === e.id);
                    if (def && def.modifiers && def.modifiers.actionSuccess && def.modifiers.actionSuccess[actionName]) {
                        delta += def.modifiers.actionSuccess[actionName];
                    }
                }
                // æˆé•¿è¢«åŠ¨ï¼šæŒ‰å€¾å‘å¯¹éƒ¨åˆ†åŠ¨ä½œæä¾›å°å¹…æˆåŠŸç‡åŠ æˆ
                if (enableGrowthBonuses.value) {
                    const key = growthTendency.value.key;
                    if (key === 'intelligence' && actionName === 'play') delta += 0.05;
                    if (key === 'morality' && (actionName === 'clean' || actionName === 'doctor')) delta += 0.05;
                    if (key === 'physical' && actionName === 'play') delta += 0.03;
                }
                return delta;
            };

            const getRacePct = (v) => {
                const val = Math.max(0, Math.min(252, Number(v || 0)));
                return (val / 255 * 100).toFixed(0) + '%';
            };
            const closeBirthModal = () => { showBirthModal.value = false; };

            const getRaceAffinityMultiplier = (actionName, option) => {
                const affinity = option.affinity || {};
                let score = 0;
                for (const [trait, weight] of Object.entries(affinity)) {
                    const traitVal = race.value[trait] || 0;
                    score += weight * (traitVal / 100);
                }
                const imagination = (race.value.imagination || 0) / 500;
                const volatility = 1 + imagination * 0.05;
                return Math.max(0.8, Math.min(1.0 + score * 0.05, 1.3)) * volatility;
            };

            const getActionEffectMultiplier = (actionName, statKey, option) => {
                let mult = 1.0;
                for (const e of activeEvents.value) {
                    const def = eventsConfig.value.events.find(ev => ev.id === e.id);
                    const key = `${actionName}.${statKey}`;
                    if (def && def.modifiers && def.modifiers.actionEffectMultiplier && def.modifiers.actionEffectMultiplier[key]) {
                        mult *= def.modifiers.actionEffectMultiplier[key];
                    }
                }
                // æˆé•¿è¢«åŠ¨ï¼šç¾åå¥½æå‡ç©è€å¸¦æ¥çš„å¿«ä¹æ”¶ç›Š
                if (enableGrowthBonuses.value) {
                    if (growthTendency.value.key === 'aesthetics' && actionName === 'play' && statKey === 'happiness') {
                        mult *= 1.05;
                    }
                }
                // å¿ƒæƒ…ä¿®æ­£ï¼šæŒ‰æŠ€èƒ½é…ç½®çš„ moodMultipliers
                if (option && option.moodMultipliers) {
                    const m = option.moodMultipliers[mood.value];
                    if (m) mult *= m;
                }
                // ç§æ—äº²å’Œåº¦
                mult *= getRaceAffinityMultiplier(actionName, option || {});
                return mult;
            };

            // æ·»åŠ æ¶ˆæ¯åˆ°å†å²
            const addMessage = (text) => {
                const time = formattedTime.value;
                messageHistory.value.unshift({time, text});
                if (messageHistory.value.length > 10) {
                    messageHistory.value.pop();
                }
            };

            // æ·»åŠ æ•ˆæœåé¦ˆ - ä¿®å¤é‡å é—®é¢˜
            const addEffectFeedback = (text, type) => {
                // ç”Ÿæˆéšæœºä½ç½®åç§»
                const offsetX = Math.floor(Math.random() * 61) - 30; // -30åˆ°30
                const offsetY = Math.floor(Math.random() * 41) - 20; // å¢åŠ Yè½´åç§»ï¼Œé¿å…é‡å 

                // ç”ŸæˆéšæœºåŠ¨ç”»æ–¹å‘ (1-3)
                const animationType = Math.floor(Math.random() * 3) + 1;

                // å°†æ–°åé¦ˆåŠ å…¥é˜Ÿåˆ—
                effectFeedbacks.value.push({
                    text,
                    class: type,
                    offsetX,
                    offsetY,
                    animation: `fadeOut${animationType}`
                });

                // å¦‚æœæ²¡æœ‰æ­£åœ¨æ˜¾ç¤ºçš„åé¦ˆï¼Œåˆ™å¼€å§‹æ˜¾ç¤ºé˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªåé¦ˆ
                if (effectFeedbacks.value.length === 1) {
                    showNextFeedback();
                }
            };

            // æ˜¾ç¤ºé˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªåé¦ˆ
            const showNextFeedback = () => {
                if (effectFeedbacks.value.length > 0) {
                    // å½“å‰æ˜¾ç¤ºç¬¬ä¸€ä¸ªåé¦ˆï¼Œè®¾ç½®ä¸€ä¸ªå®šæ—¶å™¨ï¼Œ1500æ¯«ç§’åç§»é™¤å¹¶æ˜¾ç¤ºä¸‹ä¸€ä¸ª
                    setTimeout(() => {
                        effectFeedbacks.value.shift(); // ç§»é™¤å½“å‰æ˜¾ç¤ºçš„åé¦ˆ
                        showNextFeedback(); // æ˜¾ç¤ºä¸‹ä¸€ä¸ª
                    }, 1000);
                }
            };


            // å¯¼èˆªæ§åˆ¶
            const navigate = () => {
                if (currentView.value === 'submenu') {
                    selectedSubmenuIndex.value = (selectedSubmenuIndex.value + 1) % currentSubmenuOptions.value.length;
                } else if (currentView.value === 'main') {
                    selectedActionIndex.value = (selectedActionIndex.value + 1) % actions.value.length;
                }
            };

            // å–æ¶ˆæ“ä½œ
            const cancelAction = () => {
                if (isCoolingDown.value) return;

                if (currentView.value === 'submenu') {
                    currentView.value = 'main';
                    actionFeedback.value = 'æ“ä½œå·²å–æ¶ˆ';
                    actionFeedbackClass.value = 'text-yellow-600';

                    setTimeout(() => {
                        actionFeedback.value = null;
                    }, 2000);
                } else if (currentView.value === 'status') {
                    currentView.value = 'main';
                } else {
                    currentEvent.value = null;
                }
            };

            // é€‰æ‹©å­èœå•é€‰é¡¹
            const selectSubmenuOption = (index) => {
                if (isCoolingDown.value) return;
                selectedSubmenuIndex.value = index;
            };

            // å¼€å§‹å†·å´
            const startCooldown = () => {
                if (isCoolingDown.value) return;

                isCoolingDown.value = true;
                cooldownTime.value = 3; // ç¼©çŸ­å†·å´æ—¶é—´

                cooldownInterval.value = setInterval(() => {
                    cooldownTime.value--;

                    if (cooldownTime.value <= 0) {
                        clearInterval(cooldownInterval.value);
                        isCoolingDown.value = false;
                    }
                }, 1000);
            };

            // æ‰§è¡ŒåŠ¨ä½œ
            const performAction = () => {
                if (gameOver.value || isCoolingDown.value) return;


                if (currentView.value === 'submenu') {
                    // å¼€å§‹å†·å´
                    startCooldown();
                    const action = actions.value[selectedActionIndex.value];
                    const option = currentSubmenuOptions.value[selectedSubmenuIndex.value];

                    // æ£€æŸ¥å®å®æ˜¯å¦ç¡ç€äº†
                    if (option.requireAwake && isSleeping.value) {
                        actionFeedback.value = 'å®å®ç¡ç€äº†ï¼Œæ— æ³•æ“ä½œï¼';
                        actionFeedbackClass.value = 'text-red-600';
                        currentView.value = 'main';
                        addEffectFeedback('MISS', 'feedback-miss');
                        return;
                    }

                    // æˆåŠŸç‡è®¡ç®—ï¼ˆåŸºç¡€=æŠ€èƒ½accuracyæˆ–0.8 + ä¿®æ­£ï¼‰
                    let baseAcc = typeof option.accuracy === 'number' ? option.accuracy : 0.8;
                    let successRate = baseAcc + getActionSuccessModifier(action.name);
                    successRate = Math.max(0.1, Math.min(0.95, successRate));
                    const isSuccess = Math.random() < successRate;
                    let effectMultiplier = isSuccess ? 1.0 : 0.5;
                    // surge/slumpï¼ˆâ€œå¼‚å¸¸â€ä¸â€œä½è¿·â€ï¼Œä¸å«æš´å‡»ï¼‰
                    if (isSuccess) {
                        const surgeRate = option.surgeRate || 0.0;
                        const slumpRate = option.slumpRate || 0.0;
                        const roll = Math.random();
                        if (roll < surgeRate) effectMultiplier *= 1.5;
                        else if (roll > 1 - slumpRate) effectMultiplier *= 0.5;
                    }
                    let resultMessage = option.message;

                    if (!isSuccess) {
                        resultMessage += 'ï¼ˆå¤±è´¥ï¼Œæ•ˆæœå‡åŠï¼‰';
                        addEffectFeedback('MISS', 'feedback-miss');
                    }

                    // ç‰¹æ®Šå¤„ç†ï¼šæ¢å°¿å¸ƒæ“ä½œæ¸…é™¤ä¾¿ä¾¿
                    if (option.poopClean && hasPooped.value) {
                        hasPooped.value = false;
                    }

                    // åº”ç”¨æ•ˆæœå¹¶åˆ›å»ºåé¦ˆï¼ˆäº‹ä»¶ä¿®æ­£ï¼šé…ç½®åŒ–å€ç‡ï¼‰
                    for (const [key, value] of Object.entries(option.effect)) {
                        let effectValue = value * effectMultiplier * getActionEffectMultiplier(action.name, key, option);
                        const roundedValue = Math.round(effectValue);

                        if (effectValue > 0) {
                            addEffectFeedback(`+${roundedValue} ${getStatusName(key)}`, 'feedback-positive');
                        } else if (effectValue < 0) {
                            addEffectFeedback(`${roundedValue} ${getStatusName(key)}`, 'feedback-negative');
                        }

                        status.value[key] = Math.max(0, Math.min(maxStatus.value[key], status.value[key] + effectValue));
                    }

                    // ç´¯è®¡æˆé•¿ç‚¹ï¼ˆè‹¥é…ç½®æä¾›growthï¼‰
                    if (option.growth) {
                        for (const [gk, gv] of Object.entries(option.growth)) {
                            if (growth.value[gk] !== undefined) {
                                growth.value[gk] += gv;
                            }
                        }
                    }

                    // æ·»åŠ æ¶ˆæ¯
                    addMessage(resultMessage);

                    // ç‰¹æ®Šå¤„ç†ï¼šå“„ç¡æ“ä½œ
                    if (action.name === 'sleep') {
                        // ç¡çœ æˆåŠŸç‡
                        const sleepSuccessRate = status.value.energy < maxStatus.value.energy * 0.6 ? 0.9 : 0.5;
                        if (Math.random() < sleepSuccessRate) {
                            isSleeping.value = true;
                            addMessage('å®å®ç¡ç€äº†');
                        } else {
                            addMessage('å®å®ä¸æƒ³ç¡è§‰');
                        }
                    } else if (action.name === 'status') {
                        currentView.value = 'status';
                    }
                    // ç©è€åŠ¨ä½œæœ‰50%å‡ ç‡å”¤é†’å®å®
                    if (Math.random() < 0.5) {
                        isSleeping.value = false;
                        sleepDuration.value = 0;
                        addMessage('ç©è€æƒŠé†’äº†å®å®!');
                        addEffectFeedback('æƒŠé†’!', 'feedback-negative');
                    }
                    // è¡Œä¸ºå†å²è®¡æ•°
                    if (actionHistory.value[action.name] !== undefined) {
                        actionHistory.value[action.name]++;
                    }
                    // æ›´æ–°å¿ƒæƒ…æ´¾ç”Ÿ
                    updateMood();
                    // è¿”å›ä¸»è§†å›¾
                    currentView.value = 'main';
                    actionFeedback.value = resultMessage;
                    actionFeedbackClass.value = isSuccess ? 'text-green-600' : 'text-yellow-600';
                } else if (currentView.value === 'main') {
                    const action = actions.value[selectedActionIndex.value];
                    if (action.name === 'status') {
                        currentView.value = 'status';
                    } else {
                        currentSubmenuTitle.value = action.submenu;

                        // ä»æ‰€æœ‰é€‰é¡¹ä¸­éšæœºé€‰æ‹©4ä¸ª
                        const allOptions = [...allActions.value[action.name]];
                        const shuffled = allOptions.sort(() => 0.5 - Math.random());
                        currentSubmenuOptions.value = shuffled.slice(0, 4);

                        selectedSubmenuIndex.value = 0;
                        currentView.value = 'submenu';
                    }

                }

                setTimeout(() => {
                    actionFeedback.value = null;
                }, 3000);
            };

            // æ£€æŸ¥æ¸¸æˆå¤±è´¥æ¡ä»¶
            const checkGameOver = () => {
                if (status.value.satiation <= 0) {
                    gameOver.value = true;
                    deathReason.value = "æ²¡æœ‰ç…§é¡¾å¥½å®å®çš„é¥®é£Ÿï¼";
                    return true;
                }

                if (status.value.energy <= 0) {
                    gameOver.value = true;
                    deathReason.value = "æ²¡æœ‰è®©å®å®å¾—åˆ°å……åˆ†ä¼‘æ¯ï¼";
                    return true;
                }

                if (status.value.health <= 0) {
                    gameOver.value = true;
                    deathReason.value = "æ²¡æœ‰åŠæ—¶ç…§é¡¾å®å®çš„å¥åº·ï¼";
                    return true;
                }

                if (status.value.hygiene <= 0) {
                    gameOver.value = true;
                    deathReason.value = "æ²¡æœ‰ä¿æŒå®å®æ¸…æ´å«ç”Ÿï¼";
                    return true;
                }

                if (status.value.happiness <= 0) {
                    gameOver.value = true;
                    deathReason.value = "æ²¡æœ‰å…³æ³¨å®å®çš„æƒ…ç»ªéœ€æ±‚ï¼";
                    return true;
                }

                return false;
            };

            // æ›´æ–°æœ€å¤§çŠ¶æ€å€¼ï¼ˆéšå¤©æ•°å¢åŠ ï¼‰
            const updateMaxStatus = () => {
                const growthFactor = 1 + (day.value - 1) * 0.05; // æ¯å¤©å¢é•¿5%
                for (const key in maxStatus.value) {
                    maxStatus.value[key] = Math.min(200, Math.round(100 * growthFactor));
                }
            };

            // æ¯å°æ—¶çŠ¶æ€å˜åŒ–
            const hourlyUpdate = () => {
                // æ ¹æ®æ—¶é—´å½±å“çŠ¶æ€
                if (hour.value >= 22 || hour.value < 6) {
                    // å¤œé—´ï¼šç¡è§‰æ¢å¤ç²¾åŠ›
                    if (isSleeping.value) {
                        status.value.energy = Math.min(maxStatus.value.energy, status.value.energy + 15);
                        // æ™šä¸Šï¼Œç²¾åŠ›æ¶ˆè€—å¢åŠ 
                        status.value.energy = Math.max(0, status.value.energy - 15);
                        if (status.value.energy < maxStatus.value.energy * 0.3 && !isSleeping.value) {
                            currentEvent.value = 'æƒ³ç¡è§‰';
                        }
                    } else if (hour.value >= 6 && hour.value < 12) {
                        // æ—©ä¸Šï¼Œé¥±è…¹åº¦ä¸‹é™
                        status.value.satiation = Math.max(0, status.value.satiation - 20);
                        if (status.value.satiation < maxStatus.value.satiation * 0.3) {
                            currentEvent.value = 'é¥¿äº†';
                        }
                    } else {
                        // ä¸‹åˆï¼Œä¸€èˆ¬éœ€æ±‚
                        status.value.satiation = Math.max(0, status.value.satiation - 12);
                        status.value.energy = Math.max(0, status.value.energy - 8);
                        status.value.hygiene = Math.max(0, status.value.hygiene - 10);
                    }
// å¼ºåŒ–å¥åº·/å¿«ä¹å€¼è¡°å‡
                    const healthDecay = 1 + (100 - status.value.hygiene) / 100;
                    const happinessDecay = 0.8 + (100 - Math.min(
                        status.value.satiation,
                        status.value.energy,
                        status.value.health
                    )) / 100;
                    status.value.health = Math.max(0, status.value.health - healthDecay);
                    status.value.happiness = Math.max(0, status.value.happiness - happinessDecay);
                    // å¢åŠ å¥åº·ä¸‹é™æœºåˆ¶ï¼ˆå¦‚æœä¸åŠæ—¶ç…§é¡¾ï¼‰
                    if (status.value.hygiene < 30 || status.value.satiation < 30) {
                        status.value.health -= 8;
                    }
                    // å¢åŠ ä½“é‡å˜åŒ–é€»è¾‘
                    weight.value += isSleeping.value ? 5 : 2;
                    // é…ç½®åŒ–äº‹ä»¶ï¼šæŒ‰å°æ—¶æ£€å®šè§¦å‘
                    for (const ev of eventsConfig.value.events) {
                        const chance = ev.trigger && ev.trigger.chanceHourly ? ev.trigger.chanceHourly : 0;
                        // ç®€å•æ¡ä»¶ï¼šé†’ç€/ä»»ä¸€é˜ˆå€¼
                        const whenAwake = ev.trigger && ev.trigger.whenAwake ? !isSleeping.value : true;
                        let thresholdOk = true;
                        if (ev.trigger && ev.trigger.anyBelow) {
                            thresholdOk = Object.entries(ev.trigger.anyBelow).some(([k, v]) => status.value[k] < v);
                        }
                        if (Math.random() < chance && whenAwake && thresholdOk) {
                            // æ¿€æ´»äº‹ä»¶
                            const expiresAt = day.value * 24 * 60 + hour.value * 60 + minute.value + (ev.durationMinutes || 60);
                            activeEvents.value.push({ id: ev.id, expiresAtMinute: expiresAt });
                            addMessage(`å‘ç”Ÿäº‹ä»¶ï¼š${ev.label || ev.id}`);
                            if (ev.flags && ev.flags.hasPooped) hasPooped.value = true;
                            if (ev.flags && ev.flags.isCrying) isCrying.value = true;
                        }
                    }

                    // æ ¹æ®çŠ¶æ€è®¾ç½®å©´å„¿è¡¨æƒ…
                    isCrying.value = status.value.happiness < maxStatus.value.happiness * 0.2 ||
                        status.value.health < maxStatus.value.health * 0.3 ||
                        hasPooped.value;

                    // è‡ªåŠ¨é†’æ¥
                    if (hour.value === 6 && isSleeping.value) {
                        isSleeping.value = false;
                        addMessage('å®å®è‡ªç„¶é†’äº†');
                    }

                    // ç²¾åŠ›å€¼æ»¡äº†è‡ªåŠ¨é†’æ¥
                    if (isSleeping.value && status.value.energy >= maxStatus.value.energy) {
                        isSleeping.value = false;
                        addMessage('å®å®ç¡é¥±äº†');
                    }
                    // å¢åŠ å“­æ³£è§¦å‘æ¡ä»¶

                    if (!isSleeping.value && Math.random() < 0.4 && (
                        status.value.satiation < 30 ||
                        status.value.energy < 30 ||
                        status.value.happiness < 40
                    )) {
                        isCrying.value = true;
                        addMessage('å®å®å“­é—¹äº†ï¼');
                    } else if (isCrying.value) {
                        // ä¿æŒç”±äº‹ä»¶æ§åˆ¶ï¼Œéäº‹ä»¶æ—¶é€æ­¥æ¢å¤
                        if (!activeEvents.value.find(e => e.id === 'crying')) {
                            isCrying.value = false;
                        }
                    }
                    // ç¡è§‰æ—¶å¤ªé¥¿äº†ä¼šé¥¿é†’
                    if (isSleeping.value && status.value.satiation < maxStatus.value.satiation * 0.2) {
                        isSleeping.value = false;
                        isCrying.value = true;
                        currentEvent.value = 'é¥¿é†’äº†';
                        addMessage('å®å®é¥¿é†’äº†');
                    }
                    // æ¯æ—¥ä½“é‡å¢åŠ 
                    if (hour.value === 0) {
                        const weightGain = 80 + Math.random() * 40;
                        weight.value += weightGain;
                        addMessage(`å®å®é•¿å¤§äº†ï¼ä½“é‡å¢åŠ ${Math.round(weightGain / 1000, 2)}kg`);
                    }
                }
            };


            // æ¸¸æˆä¸»å¾ªç¯
            const gameLoop = () => {
                if (gameOver.value) return;

                // æ—¶é—´æµé€ï¼ˆ1ç§’ = æ¸¸æˆå†…10åˆ†é’Ÿï¼‰
                gameTime.value += 10;
                minute.value += 10;

                if (minute.value >= 60) {
                    minute.value = 0;
                    hour.value += 1;

                    if (hour.value >= 24) {
                        hour.value = 0;
                        day.value += 1;
                        updateMaxStatus(); // æ›´æ–°æœ€å¤§çŠ¶æ€å€¼
                        addMessage(`ç¬¬${day.value}å¤©å¼€å§‹äº†ï¼å®å®æˆé•¿äº†ï¼`);
                        // æ¯æ—¥å‡çº§ï¼šæ ¹æ®å†å²è¡Œä¸ºåå¥½ï¼Œå¾®è°ƒç§æ—å€¼ï¼ˆå‘ç›¸å…³ç»´åº¦+ï¼‰
                        const inc = 5; // æ¯æ—¥æ€»åŠ æˆé¢„ç®—
                        const order = Object.entries(actionHistory.value).sort((a,b)=>b[1]-a[1]).map(x=>x[0]);
                        for (const act of order) {
                            if (act === 'play') race.value.intelligence += inc;
                            if (act === 'feed') race.value.physical += inc;
                            if (act === 'clean') race.value.morality += inc;
                            if (act === 'doctor') race.value.morality += inc;
                            if (act === 'sleep') race.value.physical += inc;
                            break; // ä»…æŒ‰æœ€åå¥½åŠ ä¸€æ¬¡
                        }
                        // æ¸…ç©ºå†å²
                        actionHistory.value = { feed: 0, clean: 0, play: 0, sleep: 0, doctor: 0 };
                    }

                    // æ¯å°æ—¶æ›´æ–°çŠ¶æ€
                    hourlyUpdate();
                }

                // çŠ¶æ€è‡ªç„¶ä¸‹é™
                status.value.satiation = Math.max(0, status.value.satiation - 0.25);

                // å¦‚æœå®å®é†’ç€ï¼Œç²¾åŠ›å€¼æ‰ä¼šä¸‹é™
                if (!isSleeping.value) {
                    status.value.energy = Math.max(0, status.value.energy - 0.15);
                } else {
                    // ç¡è§‰æ—¶æ¢å¤ç²¾åŠ›
                    status.value.energy = Math.min(maxStatus.value.energy, status.value.energy + 10);
                }

                status.value.hygiene = Math.max(0, status.value.hygiene - 0.2);

                // å¥åº·å€¼è®¡ç®—å…¬å¼ï¼ˆåŸºäºæ¸…æ´å€¼ã€é¥±è…¹å€¼å’Œç²¾åŠ›å€¼ï¼‰
                const healthModifier =
                    (status.value.hygiene / maxStatus.value.hygiene * 0.4) +
                    (status.value.satiation / maxStatus.value.satiation * 0.3) +
                    (status.value.energy / maxStatus.value.energy * 0.3);

                if (healthModifier < 0.6) {
                    status.value.health = Math.max(0, status.value.health - 0.5);
                } else {
                    status.value.health = Math.min(maxStatus.value.health, status.value.health + 0.25);
                }

                // å¿«ä¹åº¦å—å…¶ä»–çŠ¶æ€å½±å“
                let happinessModifier = 0.1; // è‡ªç„¶æ¢å¤
                if (status.value.satiation < maxStatus.value.satiation * 0.3) happinessModifier -= 0.5;
                if (status.value.energy < maxStatus.value.energy * 0.2) happinessModifier -= 0.5;
                if (status.value.hygiene < maxStatus.value.hygiene * 0.2) happinessModifier -= 0.5;
                if (status.value.health < maxStatus.value.health * 0.5) happinessModifier -= 0.75;
                if (hasPooped.value) happinessModifier -= 1.0;

                status.value.happiness = Math.max(0, Math.min(maxStatus.value.happiness, status.value.happiness + happinessModifier));

                // ä½“é‡å¢åŠ 
                if (status.value.satiation > maxStatus.value.satiation * 0.7) {
                    weight.value += 1;
                }

                    // æ¸…ç†è¿‡æœŸäº‹ä»¶ï¼ˆæŒ‰åˆ†é’Ÿç»å¯¹æ—¶é—´ï¼‰
                    const currentMinuteAbs = day.value * 24 * 60 + hour.value * 60 + minute.value;
                    const beforeCount = activeEvents.value.length;
                    activeEvents.value = activeEvents.value.filter(e => e.expiresAtMinute > currentMinuteAbs);
                    if (activeEvents.value.length < beforeCount) {
                        // æ ¹æ® flags æ¢å¤çŠ¶æ€
                        if (!activeEvents.value.find(e => e.id === 'pooped')) hasPooped.value = false;
                        if (!activeEvents.value.find(e => e.id === 'crying')) isCrying.value = false;
                    }

                // æ£€æŸ¥æ¸¸æˆå¤±è´¥æ¡ä»¶ï¼ˆå³åˆ»åˆ¤å®šï¼‰
                checkGameOver();
                if (!gameOver.value) {
                    if (status.value.satiation <= 0 || status.value.energy <= 0 || status.value.health <= 0 || status.value.hygiene <= 0 || status.value.happiness <= 0) {
                        checkGameOver();
                    }
                }
            };

            // é‡ç½®æ¸¸æˆ
            const resetGame = () => {
                maxStatus.value = {
                    satiation: 100,
                    energy: 100,
                    health: 100,
                    hygiene: 100,
                    happiness: 100
                };

                status.value = {
                    satiation: 80,
                    energy: 70,
                    health: 90,
                    hygiene: 85,
                    happiness: 75
                };

                gameTime.value = 0;
                day.value = 1;
                hour.value = 8;
                minute.value = 0;
                weight.value = 3200;
                isSleeping.value = false;
                isCrying.value = false;
                hasPooped.value = false;
                currentEvent.value = null;
                actionFeedback.value = null;
                effectFeedbacks.value = [];
                selectedActionIndex.value = 0;
                messageHistory.value = [];
                currentView.value = 'main';
                gameOver.value = false;
                deathReason.value = '';
                isCoolingDown.value = false;
                cooldownTime.value = 0;

                if (cooldownInterval.value) {
                    clearInterval(cooldownInterval.value);
                }
            };
            // æ¯åˆ†é’ŸçŠ¶æ€æ›´æ–°ï¼ˆè½»é‡çº§ï¼‰
            const minuteUpdate = () => {
                // éšæ—¶é—´ç¼“æ…¢æ¢å¤å¥åº·ï¼ˆå¦‚æœåŸºæœ¬éœ€æ±‚æ»¡è¶³ï¼‰
                if (
                    status.value.satiation > 70 &&
                    status.value.energy > 60 &&
                    status.value.hygiene > 75
                ) {
                    status.value.health = Math.min(
                        maxStatus.value.health,
                        status.value.health + 0.2
                    );
                }
                updateMood();
            };
            onMounted(async () => {
                initRace();
                // å¤–éƒ¨é…ç½®åŠ è½½ï¼ˆå¤±è´¥åˆ™ä½¿ç”¨å†…åµŒï¼‰
                try {
                    const resA = await fetch('config/actions.json');
                    if (resA.ok) {
                        allActions.value = await resA.json();
                    }
                } catch (e) { /* ignore and fallback */ }
                try {
                    const resE = await fetch('config/events.json');
                    if (resE.ok) {
                        eventsConfig.value = await resE.json();
                    }
                } catch (e) { /* ignore and fallback */ }
                gameInterval.value = setInterval(() => {
                    // æ¯600ms = æ¸¸æˆå†…10åˆ†é’Ÿ
                    gameTime.value += 600;
                    minute.value += 10;

                    if (minute.value >= 60) {
                        minute.value = 0;
                        hour.value += 1;

                        if (hour.value >= 24) {
                            hour.value = 0;
                            day.value += 1;
                            updateMaxStatus();
                        }

                        // æ¯å°æ—¶äº‹ä»¶
                        hourlyUpdate();
                    }

                    // æ¯åˆ†é’Ÿæ›´æ–°
                    minuteUpdate();

                }, 600); // æ¯0.6ç§’
                resetGame();
            });

            onUnmounted(() => {
                if (gameInterval.value) {
                    clearInterval(gameInterval.value);
                }
                if (cooldownInterval.value) {
                    clearInterval(cooldownInterval.value);
                }
            });

            return {
                maxStatus,
                status,
                gameTime,
                day,
                hour,
                minute,
                weight,
                isSleeping,
                isCrying,
                hasPooped,
                currentEvent,
                actionFeedback,
                effectFeedbacks,
                actionFeedbackClass,
                selectedActionIndex,
                messageHistory,
                currentView,
                currentSubmenuTitle,
                currentSubmenuOptions,
                selectedSubmenuIndex,
                gameOver,
                deathReason,
                actions,
                ageDisplay,
                formattedTime,
                babyState,
                babyEmoji,
                isCoolingDown,
                cooldownTime,
                getStatusColor,
                getStatusName,
                getStateIcon,
                growth,
                growthTendency,
                enableGrowthBonuses,
                mood,
                race,
                showBirthModal,
                getRacePct,
                closeBirthModal,
                navigate,
                cancelAction,
                selectSubmenuOption,
                performAction,
                resetGame
            };
        }
    }).mount('#app');
</script>
</body>
</html>