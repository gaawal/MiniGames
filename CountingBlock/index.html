<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç§¯æœ¨æ•°é‡ - 3Dç›Šæ™ºæ¸¸æˆ</title>
  <!-- æ›¿æ¢ä¸ºVueç”Ÿäº§ç‰ˆæœ¬ -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#4F46E5',
            secondary: '#10B981',
            danger: '#EF4444',
            dark: '#1F2937',
            light: '#F3F4F6'
          },
          fontFamily: {
            game: ['"Comic Sans MS"', '"Chalkboard SE"', 'sans-serif']
          }
        }
      }
    }
  </script>

  <style type="text/tailwindcss">
    @layer utilities {
      .text-shadow {
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }
      .glow {
        box-shadow: 0 0 15px rgba(79, 70, 229, 0.5);
      }
      .rotate-slow {
        animation: rotate 20s linear infinite;
      }
      @keyframes rotate {
        from { transform: rotateY(0deg); }
        to { transform: rotateY(360deg); }
      }
    }
  </style>
</head>
<body class="bg-gradient-to-br from-purple-50 to-blue-50 min-h-screen font-game text-dark">
<div id="app" class="max-w-4xl mx-auto px-4 py-8">
  <!-- æ¸¸æˆæ ‡é¢˜ -->
  <div class="text-center mb-8">
    <h1 class="text-[clamp(2rem,5vw,3.5rem)] font-bold text-primary text-shadow mb-2">
      <i class="fa-solid fa-cubes mr-3 animate-bounce"></i>ç§¯æœ¨æ•°é‡çŒœçŒœçœ‹
    </h1>
    <p class="text-gray-600 text-lg">è§‚å¯Ÿ3Dç§¯æœ¨ï¼ŒçŒœæµ‹æ€»å…±æœ‰å¤šå°‘ä¸ªï¼</p>
  </div>

  <!-- æ¸¸æˆçŠ¶æ€åŒº -->
  <div class="flex justify-between items-center mb-8 flex-wrap gap-4">
    <div class="bg-white p-3 rounded-xl shadow-md">
      <span class="text-gray-600">å½“å‰å¾—åˆ†: </span>
      <span class="text-2xl font-bold text-primary">{{ score }}</span>
    </div>

    <div class="flex gap-2">
      <span class="text-gray-600 self-center">éš¾åº¦: </span>
      <button
              v-for="(level, index) in DIFFICULTIES"
              :key="index"
              @click="selectDifficulty(level)"
              :class="[
            'px-4 py-2 rounded-lg transition-all duration-300 font-medium',
            currentDifficulty === level
              ? 'bg-primary text-white glow'
              : 'bg-white text-gray-700 hover:bg-gray-100'
          ]"
      >
        {{ level.name }}
      </button>
    </div>
  </div>

  <!-- 3Dæ¸²æŸ“åŒºåŸŸ -->
  <div class="relative bg-white rounded-2xl shadow-lg overflow-hidden mb-8 transform hover:scale-[1.01] transition-transform duration-300">
    <div class="absolute top-3 left-3 bg-primary/90 text-white text-sm px-3 py-1 rounded-full backdrop-blur-sm">
      <i class="fa-solid fa-lightbulb mr-1"></i>å¯æ—‹è½¬æŸ¥çœ‹
    </div>
    <div id="scene-container" class="w-full h-[400px] md:h-[500px]"></div>
  </div>

  <!-- çŒœæµ‹è¾“å…¥åŒºåŸŸ -->
  <div class="bg-white p-6 rounded-2xl shadow-lg mb-6">
    <div class="flex flex-col md:flex-row gap-4 items-center">
      <!-- æ•°å­—è¾“å…¥åŒºåŸŸ -->
      <div class="flex flex-wrap justify-center gap-2 mb-4 md:mb-0">
        <button
                v-for="num in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"
                :key="num"
                @click="addNumber(num)"
                class="w-12 h-12 rounded-full bg-gray-200 text-gray-800 flex items-center justify-center text-xl font-bold hover:bg-primary hover:text-white transition-all transform hover:scale-110"
        >
          {{ num }}
        </button>
      </div>

      <input
              type="hidden"
              v-model.number="userGuess"
              class="hidden"
      >

      <button
              @click="checkGuess"
              class="px-8 py-3 bg-primary text-white rounded-lg hover:bg-primary/90 transition-all transform hover:scale-105 focus:outline-none flex items-center gap-2"
      >
        <i class="fa-solid fa-paper-plane"></i>
        <span>æäº¤çŒœæµ‹</span>
      </button>
    </div>
  </div>

  <!-- æç¤ºä¿¡æ¯ -->
  <div v-if="message" class="rounded-xl p-4 text-center text-xl font-bold transition-all duration-500 transform">
    <p :class="message.type === 'success' ? 'text-secondary' : 'text-danger'">
      <i :class="message.type === 'success' ? 'fa-solid fa-check-circle mr-2' : 'fa-solid fa-exclamation-circle mr-2'"></i>
      {{ message.content }}
    </p>
  </div>

  <!-- æ¸¸æˆæŒ‡å¯¼ -->
  <div class="mt-8 bg-white/70 backdrop-blur-sm p-4 rounded-xl text-sm text-gray-600">
    <p><i class="fa-solid fa-info-circle mr-2 text-primary"></i>æ¸¸æˆè¯´æ˜ï¼šæ ¹æ®éš¾åº¦ä¸åŒï¼Œç§¯æœ¨ä¼šåœ¨ç«‹æ–¹ä½“ç©ºé—´ä¸­éšæœºç”Ÿæˆã€‚æ‰€æœ‰ç§¯æœ¨éƒ½æ˜¯ç›¸è¿çš„ï¼Œå¯ä»¥é€šè¿‡æ‹–åŠ¨é¼ æ ‡æ—‹è½¬æ¨¡å‹æŸ¥çœ‹ã€‚çŒœå¯¹è·å¾—10åˆ†ï¼ŒçŒœé”™åˆ™æ˜¾ç¤ºæ­£ç¡®ç­”æ¡ˆã€‚</p>
  </div>
</div>

<script>
  // å½©è™¹é¢œè‰²æ•°ç»„
  const RAINBOW_COLORS = [
    0xFF5252, // çº¢
    0xFF9800, // æ©™
    0xFFEB3B, // é»„
    0x4CAF50, // ç»¿
    0x2196F3, // è“
    0x9C27B0, // ç´«
    0xFF4081  // ç²‰
  ];

  // éš¾åº¦é…ç½®ï¼ˆä»5*5*5å¼€å§‹ï¼Œæœ€å°‘6ä¸ªæ–¹å—ï¼‰
  const DIFFICULTIES = [
    { name: 'ç®€å•', m: 5, minCount: 6, maxCount: 8 },  // 5x5x5 ç«‹æ–¹ä½“
    { name: 'ä¸­ç­‰', m: 6, minCount: 8, maxCount: 12 },  // 6x6x6 ç«‹æ–¹ä½“
    { name: 'å›°éš¾', m: 7, minCount: 10, maxCount: 15 }  // 7x7x7 ç«‹æ–¹ä½“
  ];

  const app = Vue.createApp({
    data() {
      return {
        DIFFICULTIES,
        currentDifficulty: DIFFICULTIES[0],
        userGuess: null,
        message: null,
        score: 0,
        blocks: [], // ç§¯æœ¨åæ ‡ï¼ˆéå“åº”å¼å¯¹è±¡ï¼‰
        m: 5,       // å½“å‰ç«‹æ–¹ä½“ç»´åº¦
        targetCount: 0 // ç›®æ ‡ç§¯æœ¨æ•°é‡
      };
    },

    mounted() {
      // åˆå§‹åŒ–Three.jsï¼ˆéå“åº”å¼å¯¹è±¡ï¼‰
      this.initThreeJS();
      this.generateNewGame();
      this.setupEventListeners();
    },

    methods: {
      // åˆå§‹åŒ–Three.jsï¼ˆéå“åº”å¼å¯¹è±¡ï¼‰
      initThreeJS() {
        const container = document.getElementById('scene-container');

        // æ ¸å¿ƒå¯¹è±¡ï¼ˆç§»å‡ºVueå“åº”å¼ï¼‰
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();

        // åœºæ™¯é…ç½®
        this.scene.background = new THREE.Color(0xffffff);

        // ç›¸æœºä½ç½®
        this.camera.position.set(this.m * 1.5, this.m * 1.5, this.m * 1.5);
        this.camera.lookAt(this.m/2 - 0.5, this.m/2 - 0.5, this.m/2 - 0.5);

        // æ¸²æŸ“å™¨é…ç½®
        this.renderer.setSize(container.clientWidth, container.clientHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(this.renderer.domElement);

        // ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);

        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight1.position.set(1, 1, 1);
        this.scene.add(directionalLight1);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight2.position.set(-1, -1, -1);
        this.scene.add(directionalLight2);

        // æ¸²æŸ“å¾ªç¯ï¼ˆéå“åº”å¼ï¼‰
        this.renderLoop = () => {
          requestAnimationFrame(this.renderLoop);
          this.renderer.render(this.scene, this.camera);
        };
        this.renderLoop();
      },

      // è®¾ç½®äº‹ä»¶ç›‘å¬ï¼ˆå¤„ç†passiveè­¦å‘Šï¼‰
      setupEventListeners() {
        const container = document.getElementById('scene-container');
        let isDragging = false;
        let previousMouse = { x: 0, y: 0 };

        // é¼ æ ‡äº‹ä»¶
        container.addEventListener('mousedown', (e) => {
          isDragging = true;
          previousMouse = { x: e.clientX, y: e.clientY };
        });

        window.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          const deltaX = e.clientX - previousMouse.x;
          const deltaY = e.clientY - previousMouse.y;
          this.scene.rotation.y += deltaX * 0.005;
          this.scene.rotation.x += deltaY * 0.005;
          this.scene.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.scene.rotation.x));
          previousMouse = { x: e.clientX, y: e.clientY };
        });

        window.addEventListener('mouseup', () => isDragging = false);

        // è§¦æ‘¸äº‹ä»¶ï¼ˆæ·»åŠ passiveé€‰é¡¹ï¼‰
        container.addEventListener('touchstart', (e) => {
          isDragging = true;
          previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }, { passive: true }); // æ— preventDefaultï¼Œè®¾ä¸ºpassive

        window.addEventListener('touchmove', (e) => {
          if (!isDragging) return;
          const deltaX = e.touches[0].clientX - previousMouse.x;
          const deltaY = e.touches[0].clientY - previousMouse.y;
          this.scene.rotation.y += deltaX * 0.005;
          this.scene.rotation.x += deltaY * 0.005;
          this.scene.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.scene.rotation.x));
          previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          e.preventDefault(); // é˜»æ­¢é»˜è®¤æ»šåŠ¨
        }, { passive: false }); // æœ‰preventDefaultï¼Œè®¾ä¸ºfalse

        window.addEventListener('touchend', () => isDragging = false, { passive: true });

        // çª—å£resize
        window.addEventListener('resize', () => {
          const container = document.getElementById('scene-container');
          this.camera.aspect = container.clientWidth / container.clientHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(container.clientWidth, container.clientHeight);
        });
      },

      // é€‰æ‹©éš¾åº¦
      selectDifficulty(level) {
        this.currentDifficulty = level;
        this.m = level.m;
        this.generateNewGame();
        // è°ƒæ•´ç›¸æœºä½ç½®
        this.camera.position.set(this.m * 1.5, this.m * 1.5, this.m * 1.5);
        this.camera.lookAt(this.m/2 - 0.5, this.m/2 - 0.5, this.m/2 - 0.5);
      },

      // ç”Ÿæˆæ–°æ¸¸æˆ
      generateNewGame() {
        // éšæœºç›®æ ‡æ•°é‡
        this.targetCount = Math.floor(
                Math.random() * (this.currentDifficulty.maxCount - this.currentDifficulty.minCount + 1)
        ) + this.currentDifficulty.minCount;

        // ç”Ÿæˆç›¸è¿ç§¯æœ¨
        try {
          this.blocks = this.generateConnectedBlocks(this.currentDifficulty.m, this.targetCount);
        } catch (error) {
          console.error('ç”Ÿæˆç§¯æœ¨å¤±è´¥:', error);
          this.message = { type: 'error', content: 'ç”Ÿæˆç§¯æœ¨å¤±è´¥ï¼Œè¯·é‡è¯•' };
          setTimeout(() => this.generateNewGame(), 1000);
          return;
        }

        // ç¡®ä¿è‡³å°‘2å±‚é«˜åº¦
        const zCoords = this.blocks.map(b => b.z);
        const minZ = Math.min(...zCoords);
        const maxZ = Math.max(...zCoords);
        const height = maxZ - minZ + 1;
        if (height < 2) {
          this.generateNewGame();
          return;
        }

        // ç¡®ä¿æ€»ä½“æ–¹å—æ•°é‡è‡³å°‘6ä¸ª
        if (this.blocks.length < 6) {
          this.generateNewGame();
          return;
        }

        // ç¡®ä¿ç«‹æ–¹ä½“ç©ºé—´æ¯”ç”Ÿæˆçš„æ–¹å—ç©ºé—´å¤§3
        const cubeSize = this.currentDifficulty.m + 3;
        this.m = cubeSize; // ç¡®ä¿åœºæ™¯å¤§å°

        // è°ƒæ•´ç›¸æœºä½ç½®
        this.camera.position.set(this.m * 1.5, this.m * 1.5, this.m * 1.5);
        this.camera.lookAt(this.m/2 - 0.5, this.m/2 - 0.5, this.m/2 - 0.5);

        // æ¸²æŸ“ç§¯æœ¨ï¼ˆæ¸…ç©ºåœºæ™¯ï¼‰
        this.renderBlocks();

        // é‡ç½®çŠ¶æ€
        this.userGuess = null;
        this.message = null;
      },

      // ç”Ÿæˆç›¸è¿ç§¯æœ¨ï¼ˆç”Ÿé•¿æ³•ï¼‰
      generateConnectedBlocks(m, targetCount) {
        const blocks = new Set();
        const start = `${Math.floor(Math.random()*m)},${Math.floor(Math.random()*m)},${Math.floor(Math.random()*m)}`;
        blocks.add(start);

        // å¾…æ‰©å±•çš„ç›¸é‚»æ ¼å­
        const candidates = new Set(this.getAdjacent(start, m));

        while (blocks.size < targetCount) {
          if (candidates.size === 0) throw new Error('æ— æ³•ç”Ÿæˆè¶³å¤Ÿç›¸è¿ç§¯æœ¨');
          const [coord] = Array.from(candidates).sort(() => Math.random() - 0.5);
          blocks.add(coord);
          candidates.delete(coord);
          this.getAdjacent(coord, m).forEach(c => {
            if (!blocks.has(c) && !candidates.has(c)) candidates.add(c);
          });
        }

        // è½¬æ¢ä¸ºåæ ‡å¯¹è±¡
        return Array.from(blocks).map(coord => {
          const [x, y, z] = coord.split(',').map(Number);
          return { x, y, z };
        });
      },

      // è·å–ç›¸é‚»æ ¼å­ï¼ˆåæ ‡å­—ç¬¦ä¸²ï¼‰
      getAdjacent(coord, m) {
        const [x, y, z] = coord.split(',').map(Number);
        const dirs = [[1,0,0], [-1,0,0], [0,1,0], [0,-1,0], [0,0,1], [0,0,-1]];
        return dirs.map(([dx, dy, dz]) => {
          const nx = x + dx;
          const ny = y + dy;
          const nz = z + dz;
          if (nx >=0 && nx < m && ny >=0 && ny < m && nz >=0 && nz < m) {
            return `${nx},${ny},${nz}`;
          }
        }).filter(Boolean);
      },

      // æ¸²æŸ“ç§¯æœ¨ï¼ˆæ¸…ç©ºåœºæ™¯å¹¶é‡æ–°ç»˜åˆ¶ï¼‰
      renderBlocks() {
        // æ¸…ç©ºåœºæ™¯ï¼ˆä¿ç•™ç¯å…‰ï¼‰
        this.scene.children = this.scene.children.filter(child =>
                child.type === 'AmbientLight' || child.type === 'DirectionalLight'
        );

        // ç»˜åˆ¶ç«‹æ–¹ä½“è¾¹æ¡†
        const edgeGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(this.m, this.m, this.m));
        const edgeMat = new THREE.LineBasicMaterial({ color: 0xcccccc });
        const edge = new THREE.LineSegments(edgeGeo, edgeMat);
        edge.position.set(this.m/2 - 0.5, this.m/2 - 0.5, this.m/2 - 0.5);
        this.scene.add(edge);

        // ç»˜åˆ¶ç§¯æœ¨
        const size = 1.0; // ç§¯æœ¨å¤§å°ï¼ˆæ²¡æœ‰é—´éš™ï¼‰
        this.blocks.forEach(block => {
          const geo = new THREE.BoxGeometry(size, size, size);
          const color = RAINBOW_COLORS[Math.floor(Math.random() * RAINBOW_COLORS.length)];
          const mat = new THREE.MeshStandardMaterial({
            color,
            roughness: 0.5,
            metalness: 0.2
          });

          // æ·»åŠ æè¾¹
          const edgeGeo = new THREE.EdgesGeometry(geo);
          const edgeMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1.5 });
          const edgeMesh = new THREE.LineSegments(edgeGeo, edgeMat);

          const cube = new THREE.Mesh(geo, mat);
          cube.position.set(block.x, block.y, block.z);
          cube.add(edgeMesh);

          this.scene.add(cube);
        });
      },

      // æ·»åŠ æ•°å­—
      addNumber(num) {
        if (this.userGuess === null) {
          this.userGuess = num;
        } else {
          this.userGuess = this.userGuess * 10 + num;
        }
      },

      // æ£€æŸ¥çŒœæµ‹
      checkGuess() {
        if (this.userGuess == null || this.userGuess < 1) {
          this.message = { type: 'error', content: 'è¯·è¾“å…¥æœ‰æ•ˆæ•°é‡ï¼' };
          return;
        }

        if (this.userGuess === this.targetCount) {
          this.score += 10;
          this.message = { type: 'success', content: `ğŸ‰ çŒœå¯¹äº†ï¼ç§¯æœ¨æ•°é‡æ˜¯ ${this.targetCount}ï¼Œè·å¾— 10 åˆ†ï¼` };
          setTimeout(() => this.generateNewGame(), 2000);
        } else {
          this.message = { type: 'error', content: `âŒ çŒœé”™äº†ï¼æ­£ç¡®æ•°é‡æ˜¯ ${this.targetCount}ï¼Œå†æ¥å†å‰ï¼` };
        }
      }
    }
  });

  app.mount('#app');
</script>
</body>
</html>
